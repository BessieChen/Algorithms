//
//  main.cpp
//  Graph_Rewrite
//
//  Created by 陈贝茜 on 2019/8/21.
//  Copyright © 2019 Bessie Chen. All rights reserved.
//

#include <iostream>
#include "SparseGraph.h"
#include "DenseGraph.h"
#include "main1.h"
#include "main2.h"
#include "Component.h"

using std::cout;
using std::cin;
using std::endl;

int main(int argc, const char * argv[]) {
    
    main1();
    main2();
    
    return 0;
}

/*
 2019.8.21
 ——————————————————
 平行边，自环边
 稠密图：矩阵：天然的没有平行边，没有自环边
 稀疏图：list：如果你不要平行边，先判断有没有hasEdge(), 如果不要自环边，加上if(v!=w)
 ——————————————————
 目的：邻接表的优势：
 矩阵：找一个节点的邻接节点的时间复杂度是O(v)，v是节点个数。
 ——————————————————
 目的：想要找到某个节点的邻接节点，将g public，然后拿到g[v]去遍历，坏处是暴露，索引引进迭代器：
 细节：因为graph是一个引用，所以可以用构造列表来初始化G.另外注意我们之后调用的是G.graph和G.n
 注意我们的迭代器返回的是不是index，而是真的节点的名字。或者说其实index就是我们的节点的名字。我们的节点名字是连续的，从0开始的一直到n-1
 ——————————————————
 遍历所有点的所有临边：
 一个是O(E)
 一个是O(V^2)
 ——————————————————
 ReadGraph: 模板类
 Typename：因为编译器不知道adjIterator是Graph的里面一个类型还是Graph的一个成员变量。
 ——————————————————
 为什么path使用stack？因为我们设置的是from[]只能记录上一个元素的位置。只能记录来源。
 如果如果不用stack，而是直接往list后面加，我们会发现越后面越是源头。然而我们的答案需要第一个是源头。
 另外，不设置to[]是因为，你可以试试？
 ——————————————————
 Dfs:联通分量+路径+环(未学)
 Bfs:最短路径
 ——————————————————
 为什么bfs是ord[i] = ord[v] + 1, 而不是id[I] = count;
 ——————————————————
 Bfs有时候和dfs的结果一样，看你的数据是怎么存储的，所以不一定就是dfs不好
 另外有时候bfs会有多条，如何全部最短路径都打印出来，涉及到动态规划。
 */


/*
 1 2 3 4 5
 
 0: 15 18 3 17 8 5 1 14 7
 1: 16 13 7 4 14 0 9 19 10 15 17 18 11
 2: 17 5 10 12 14 16 9 6
 3: 0 16 12 17 15 11
 4: 16 5 4 15 1 9 17 7
 5: 4 15 11 2 16 14 0 19 10 17 12
 6: 17 11 19 13 9 16 2
 7: 15 1 17 10 0 4
 8: 11 9 19 0 15 17
 9: 16 8 6 15 10 4 1 14 12 2
 10: 9 12 2 17 1 5 7 19 15 13
 11: 12 6 8 5 19 3 1
 12: 11 10 2 3 18 16 9 14 5
 13: 1 6 18 17 15 10
 14: 2 1 5 9 0 12
 15: 0 7 5 9 4 3 8 13 1 10
 16: 1 4 9 16 3 5 12 19 2 6
 17: 6 2 0 7 4 10 3 13 17 8 1 5
 18: 0 18 12 13 1
 19: 6 8 16 11 1 5 10
 
 0: 1 3 5 7 8 14 15 17 18
 1: 0 4 7 9 10 11 13 14 15 16 17 18 19
 2: 5 6 9 10 12 14 16 17
 3: 0 11 12 15 16 17
 4: 1 4 5 7 9 15 16 17
 5: 0 2 4 10 11 12 14 15 16 17 19
 6: 2 9 11 13 16 17 19
 7: 0 1 4 10 15 17
 8: 0 9 11 15 17 19
 9: 1 2 4 6 8 10 12 14 15 16
 10: 1 2 5 7 9 12 13 15 17 19
 11: 1 3 5 6 8 12 19
 12: 2 3 5 9 10 11 14 16 18
 13: 1 6 10 15 17 18
 14: 0 1 2 5 9 12
 15: 0 1 3 4 5 7 8 9 10 13
 16: 1 2 3 4 5 6 9 12 16 19
 17: 0 1 2 3 4 5 6 7 8 10 13 17
 18: 0 1 12 13 18
 19: 1 5 6 8 10 11 16
 
 test G1 in Sparse Graph:
 0: 5, 1, 2, 6
 1: 0
 2: 0
 3: 4, 5
 4: 3, 6, 5
 5: 0, 4, 3
 6: 4, 0
 7: 8
 8: 7
 9: 12, 10, 11
 10: 9
 11: 12, 9
 12: 9, 11
 
 test G1 in Dense Graph:
 0: 0 1 1 0 0 1 1 0 0 0 0 0 0
 1: 1 0 0 0 0 0 0 0 0 0 0 0 0
 2: 1 0 0 0 0 0 0 0 0 0 0 0 0
 3: 0 0 0 0 1 1 0 0 0 0 0 0 0
 4: 0 0 0 1 0 1 1 0 0 0 0 0 0
 5: 1 0 0 1 1 0 0 0 0 0 0 0 0
 6: 1 0 0 0 1 0 0 0 0 0 0 0 0
 7: 0 0 0 0 0 0 0 0 1 0 0 0 0
 8: 0 0 0 0 0 0 0 1 0 0 0 0 0
 9: 0 0 0 0 0 0 0 0 0 0 1 1 1
 10: 0 0 0 0 0 0 0 0 0 1 0 0 0
 11: 0 0 0 0 0 0 0 0 0 1 0 0 1
 12: 0 0 0 0 0 0 0 0 0 1 0 1 0
 
 test G2 in Sparse Graph:
 0: 1, 2, 5
 1: 0, 2, 3, 4
 2: 0, 1
 3: 1, 4, 5
 4: 1, 3
 5: 0, 3
 
 test G2 in Dense Graph:
 0: 0 1 1 0 0 1
 1: 1 0 1 1 1 0
 2: 1 1 0 0 0 0
 3: 0 1 0 0 1 1
 4: 0 1 0 1 0 0
 5: 1 0 0 1 0 0
 
 Program ended with exit code: 0
 */
